<?php

namespace Squirrel\Queries\Tests;

use Doctrine\DBAL\Connection;
use Doctrine\DBAL\Statement;
use Squirrel\Queries\Doctrine\DBPostgreSQLImplementation;
use Squirrel\Queries\Exception\DBInvalidOptionException;

/**
 * Test custom PostgreSQL implementation parts
 */
class DoctrinePostgreSQLImplementationTest extends \PHPUnit\Framework\TestCase
{
    /**
     * @var DBPostgreSQLImplementation
     */
    private $db;

    /**
     * @var Connection
     */
    private $connection;

    /**
     * Prepare common aspects of all tests
     */
    protected function setUp(): void
    {
        // Mock of the Doctrine Connection class
        $this->connection = \Mockery::mock(Connection::class);
        $this->connection->shouldReceive('quoteIdentifier')->andReturnUsing([$this, 'quoteIdentifier']);

        // MySQL implementation class
        $this->db = new DBPostgreSQLImplementation($this->connection);
    }

    /**
     * Test vanilla upsert without explicit update part
     */
    public function testUpsert()
    {
        // SQL query which should be generated by the implementation
        $sql = 'INSERT INTO ' . $this->quoteIdentifier('example.example') .
            ' (' .
            $this->quoteIdentifier('id') . ',' .
            $this->quoteIdentifier('id2') . ',' .
            $this->quoteIdentifier('name') . ',' .
            $this->quoteIdentifier('bla43') . ',' .
            $this->quoteIdentifier('judihui') .
            ') VALUES (?,?,?,?,?) ' .
            'ON CONFLICT (' . $this->quoteIdentifier('id') . ',' . $this->quoteIdentifier('id2') . ') DO UPDATE ' .
            $this->quoteIdentifier('name') . '=?,' .
            $this->quoteIdentifier('bla43') . '=?,' .
            $this->quoteIdentifier('judihui') . '=?';

        // Statement and the data values it should receive
        $statement = \Mockery::mock(Statement::class);
        $statement
            ->shouldReceive('execute')
            ->once()
            ->with(\Mockery::mustBe([
                5,
                6,
                'value',
                'niiiiice',
                5,
                'value',
                'niiiiice',
                5,
            ]));
        $statement
            ->shouldReceive('rowCount')
            ->once()
            ->andReturn(1);

        // SQL query should be received by "prepare"
        $this->connection
            ->shouldReceive('prepare')
            ->once()
            ->with(\Mockery::mustBe($sql))
            ->andReturn($statement);

        // Close result set
        $statement
            ->shouldReceive('closeCursor')
            ->once();

        // Test the upsert
        $result = $this->db->upsert('example.example', [
            'id' => 5,
            'id2' => 6,
            'name' => 'value',
            'bla43' => 'niiiiice',
            'judihui' => 5,
        ], [
            'id',
            'id2',
        ]);

        // Should return 1
        $this->assertSame(1, $result);
    }

    /**
     * Recreated quoteIdentifier function as a standin for the Doctrine one
     *
     * @param string $identifier
     * @return string
     */
    public function quoteIdentifier(string $identifier): string
    {
        if (strpos($identifier, ".") !== false) {
            $parts = array_map(
                function ($p) {
                    return '"' . str_replace('"', '""', $p) . '"';
                },
                explode(".", $identifier)
            );

            return implode(".", $parts);
        }

        return '"' . str_replace('"', '""', $identifier) . '"';
    }

    /**
     * Test upsert with an explicit update part
     */
    public function testUpsertCustomUpdate()
    {
        // SQL query which should be generated by the implementation
        $sql = 'INSERT INTO ' . $this->quoteIdentifier('example.example') . ' (' .
            $this->quoteIdentifier('id') . ',' .
            $this->quoteIdentifier('id2') . ',' .
            $this->quoteIdentifier('name') . ',' .
            $this->quoteIdentifier('bla43') . ',' .
            $this->quoteIdentifier('judihui') .
            ') VALUES (?,?,?,?,?) ' .
            'ON CONFLICT (' . $this->quoteIdentifier('id') . ',' . $this->quoteIdentifier('id2') . ') DO UPDATE ' .
            $this->quoteIdentifier('name') . '=?,' .
            $this->quoteIdentifier('lala45') . '=?,judihui = judihui + 1,' .
            $this->quoteIdentifier('evenmore') . '=?,' .
            $this->quoteIdentifier('lastone') . '=?';

        // Statement and the data values it should receive
        $statement = \Mockery::mock(Statement::class);
        $statement
            ->shouldReceive('execute')
            ->once()
            ->with(\Mockery::mustBe([
                5,
                6,
                'value',
                'niiiiice',
                5,
                'value5',
                '534',
                8,
                'laaaast',
            ]));
        $statement
            ->shouldReceive('rowCount')
            ->once()
            ->andReturn(2);

        // SQL query should be received by "prepare"
        $this->connection
            ->shouldReceive('prepare')
            ->once()
            ->with(\Mockery::mustBe($sql))
            ->andReturn($statement);

        // Close result set
        $statement
            ->shouldReceive('closeCursor')
            ->once();

        // Test the upsert
        $result = $this->db->upsert('example.example', [
            'id' => 5,
            'id2' => 6,
            'name' => 'value',
            'bla43' => 'niiiiice',
            'judihui' => 5,
        ], [
            'id',
            'id2',
        ], [
            'name' => 'value5',
            'lala45' => '534',
            'judihui = judihui + 1',
            'evenmore' => 8,
            'lastone' => 'laaaast',
        ]);

        // Should return 2
        $this->assertSame(2, $result);
    }

    /**
     * Test upsert with an explicit update part and escapeable variables in there
     */
    public function testUpsertCustomUpdateWithVars()
    {
        // SQL query which should be generated by the implementation
        $sql = 'INSERT INTO ' . $this->quoteIdentifier('example.example') . ' (' .
            $this->quoteIdentifier('id') . ',' .
            $this->quoteIdentifier('id2') . ',' .
            $this->quoteIdentifier('name') . ',' .
            $this->quoteIdentifier('bla43') . ',' .
            $this->quoteIdentifier('judihui') .
            ') VALUES (?,?,?,?,?) ' .
            'ON CONFLICT (' . $this->quoteIdentifier('id') . ',' . $this->quoteIdentifier('id2') . ') DO UPDATE ' .
            $this->quoteIdentifier('name') . '=?,' .
            $this->quoteIdentifier('lala45') . '=?,' .
            $this->quoteIdentifier('judihui') . ' = ' . $this->quoteIdentifier('judihui') . ' + 1,' .
            $this->quoteIdentifier('judihui') . ' = ' . $this->quoteIdentifier('judihui') . ' + ?,' .
            $this->quoteIdentifier('judihui') . ' = ' . $this->quoteIdentifier('judihui') . ' + ? + ? + ? - ?,' .
            $this->quoteIdentifier('evenmore') . '=?,' . $this->quoteIdentifier('lastone') . '=?';

        // Statement and the data values it should receive
        $statement = \Mockery::mock(Statement::class);
        $statement
            ->shouldReceive('execute')
            ->once()
            ->with(\Mockery::mustBe([
                5,
                6,
                'value',
                'niiiiice',
                5,
                'value5',
                '534',
                13,
                13,
                18,
                67,
                'dada',
                8,
                'laaaast',
            ]));
        $statement
            ->shouldReceive('rowCount')
            ->once()
            ->andReturn(2);

        // SQL query should be received by "prepare"
        $this->connection
            ->shouldReceive('prepare')
            ->once()
            ->with(\Mockery::mustBe($sql))
            ->andReturn($statement);

        // Close result set
        $statement
            ->shouldReceive('closeCursor')
            ->once();

        // Test the upsert
        $result = $this->db->upsert('example.example', [
            'id' => 5,
            'id2' => 6,
            'name' => 'value',
            'bla43' => 'niiiiice',
            'judihui' => 5,
        ], [
            'id',
            'id2',
        ], [
            'name' => 'value5',
            'lala45' => '534',
            ':judihui: = :judihui: + 1',
            ':judihui: = :judihui: + ?' => 13,
            ':judihui: = :judihui: + ? + ? + ? - ?' => [13, 18, 67, 'dada'],
            'evenmore' => 8,
            'lastone' => 'laaaast',
        ]);

        // Should return 2
        $this->assertSame(2, $result);
    }

    /**
     * Test upsert with an explicit update part and escapeable variables in there
     */
    public function testUpsertNoUpdateRows()
    {
        // SQL query which should be generated by the implementation
        $sql = 'INSERT INTO ' . $this->quoteIdentifier('example.example') . ' (' .
            $this->quoteIdentifier('id') . ',' .
            $this->quoteIdentifier('id2') .
            ') VALUES (?,?) ' .
            'ON CONFLICT (' . $this->quoteIdentifier('id') . ',' . $this->quoteIdentifier('id2') . ') DO UPDATE 1=1';

        // Statement and the data values it should receive
        $statement = \Mockery::mock(Statement::class);
        $statement
            ->shouldReceive('execute')
            ->once()
            ->with(\Mockery::mustBe([
                5,
                6,
            ]));
        $statement
            ->shouldReceive('rowCount')
            ->once()
            ->andReturn(2);

        // SQL query should be received by "prepare"
        $this->connection
            ->shouldReceive('prepare')
            ->once()
            ->with(\Mockery::mustBe($sql))
            ->andReturn($statement);

        // Close result set
        $statement
            ->shouldReceive('closeCursor')
            ->once();

        // Test the upsert
        $result = $this->db->upsert('example.example', [
            'id' => 5,
            'id2' => 6,
        ], [
            'id',
            'id2',
        ]);

        // Should return 2
        $this->assertSame(2, $result);
    }

    public function testUpsertInvalidOptionNoTableName()
    {
        // Expect an InvalidOptions exception
        $this->expectException(DBInvalidOptionException::class);

        // Try it with the invalid option
        $this->db->upsert('', [
            'dada' => 5,
            'fieldname' => 'rowvalue',
        ]);
    }

    public function testUpsertInvalidOptionNoRow()
    {
        // Expect an InvalidOptions exception
        $this->expectException(DBInvalidOptionException::class);

        // Try it with the invalid option
        $this->db->upsert('table');
    }
}
